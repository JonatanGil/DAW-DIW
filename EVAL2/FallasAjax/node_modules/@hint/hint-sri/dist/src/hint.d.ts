/**
 * @fileoverview Require scripts and styles to use Subresource Integrity
 */
import { HintContext } from 'hint/dist/src/lib/hint-context';
import { IHint } from 'hint/dist/src/lib/types';
export default class SRIHint implements IHint {
    static readonly meta: import("hint/dist/src/lib/types").HintMetadata;
    private context;
    private origin;
    private finalUrl;
    private baseline;
    private originCriteria;
    private cache;
    /** Contains the keys cache keys for the element already reported. */
    private reportedKeys;
    /**
     * Returns the hash of the content for the given `sha` strengh in a format
     * valid with SRI:
     * * base64
     * * `sha384-hash`
     */
    private calculateHash;
    /**
     * Checks if the element that originated the request/response is a
     * `script` or a `stylesheet`. There could be other downloads from
     * a `link` element that are not stylesheets and should be ignored.
     */
    private isScriptOrLink;
    private report;
    /**
     * Verifies if the response is eligible for integrity validation. I.E.:
     *
     * * `same-origin`
     * * `cross-origin` on a CORS-enabled request
     *
     * More info in https://w3c.github.io/webappsec-subresource-integrity/#is-response-eligible
     */
    private isEligibleForIntegrityValidation;
    /**
     * Checks if the element that triggered the download has the `integrity`
     * attribute if required based on the selected origin criteria.
     */
    private hasIntegrityAttribute;
    /**
     * Checks if the format of the `integrity` attribute is valid and if the used hash meets
     * the baseline (by default sha-384). In the case of multiple algorithms used, the
     * one with the highest priority is the used one to validate. E.g.:
     *
     * * `<script src="https://example.com/example-framework.js"
     *   integrity="sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7"
     *   crossorigin="anonymous"></script>`
     * * `<script src="https://example.com/example-framework.js"
     *   integrity="sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7
     *              sha384-+/M6kredJcxdsqkczBUjMLvqyHb1K/JThDXWsBVxMEeZHEaMKEOEct339VItX1zB"
     *   crossorigin="anonymous"></script>`
     *
     * https://w3c.github.io/webappsec-subresource-integrity/#agility
     */
    private isIntegrityFormatValid;
    /**
     * Checks if the resources is being delivered via HTTPS.
     *
     * More info: https://w3c.github.io/webappsec-subresource-integrity/#non-secure-contexts
     */
    private isSecureContext;
    /**
     * Calculates if the hash is the right one for the downloaded resource.
     *
     * An `integrity` attribute can have multiple hashes for the same algorithm and it will
     * pass as long as one validates.
     *
     * More info: https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
     */
    private hasRightHash;
    private getCache;
    private getCacheKey;
    private addToCache;
    /**
     * If the resource is a local file, ignore the analysis.
     * The sri usually is added on the building process before publish,
     * so is going to be very common that the sri doesn't exists
     * for local files.
     */
    private isNotLocalResource;
    /**
     * The item is cached. For the VSCode extension and the
     * local connector with option 'watch' activated we
     * should report what we have in the cache after the
     * first 'scan::end'.
     */
    private isInCache;
    /**
     * `requestAsync` is not included in webpack bundle for `extension-browser`.
     * This is ok because the browser will have already requested this via `fetch::end`
     * events.
     *
     * Note: We are not using `Requester` because it depends on `iltorb` and it can
     * cause problems with the vscode-extension because `iltorb` depends on the
     * node version for which it was compiled.
     *
     * We can probably use Requester once https://github.com/webhintio/hint/issues/1604 is done,
     * and vscode use the node version that support it.
     *
     * When using crossorigin="use-credentials" and the response contains
     * the header `Access-Control-Allow-Origin` with value `*` Chrome blocks the access
     * to the resource by CORS policy, so we will reach this point
     * through the traverse of the dom and response.body.content will be ''. In this case,
     * we have to prevent the download of the resource.
     */
    private downloadContent;
    private isNotIgnored;
    /** Validation entry point. */
    private validateResource;
    /**
     * Validation entry point for event element::script
     * or element::link
     */
    private validateElement;
    /** Sets the `origin` property using the initial request. */
    private setOrigin;
    private onScanEnd;
    constructor(context: HintContext);
}
//# sourceMappingURL=hint.d.ts.map