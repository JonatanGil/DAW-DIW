"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const acornWalk = require("acorn-walk");
const { extend } = require('acorn-jsx-walk');
extend(acornWalk.base); // Add `walk` support for JSXElement, etc.
exports.base = acornWalk.base;
const getCurrentVisitorsOrCallback = (walkArray, node, base, state) => {
    const item = walkArray.find(([key]) => {
        return key.node === node && key.base === base && key.state === state;
    });
    return item ? item[1] : null;
};
const defaultCallbacksProperty = 'callbacks';
/**
 * After all the hints have registered their NodeVisitor or callback,
 * it is time to generate a single NodeVisitor for each different
 * NodeVisitor registered by the hints and execute the real walk.
 *
 * Continuing with the previous example, this code will execute:
 *
 * acornWalk.simple(ast, {
 *     CallExpresion(node) {
 *         // code from CallExpression in hint 1
 *         // code from CallExpression in hint 2
 *     },
 *     Literal(node) {
 *         // code from Literal in hint 3
 *     }
 * });
 *
 * acornWalk.full(ast, (node) => {
 *     // code from callback in hint 4
 * });
 */
const performWalk = (walkArrays) => {
    Object.entries(walkArrays).forEach(([methodName, walkArray]) => {
        walkArray.forEach(([{ node, state, base }, visitors]) => {
            let allVisitors = {};
            if (visitors.has(defaultCallbacksProperty)) {
                // `full` and `fullAncestor` only track an array of callbacks.
                const callbacks = visitors.get(defaultCallbacksProperty);
                /* istanbul ignore next */
                allVisitors = (callbackNode, callbackState, typeOrAncestors) => {
                    callbacks.forEach((callback) => {
                        callback(callbackNode, callbackState, typeOrAncestors);
                    });
                };
            }
            else {
                // `ancestor` and `simple` track an array of NodeVisitors which need merged.
                for (const [name, callbacks] of visitors) {
                    /* istanbul ignore next */
                    allVisitors[name] = (callbackNode, ancestors) => {
                        callbacks.forEach((callback) => {
                            callback(callbackNode, ancestors);
                        });
                    };
                }
            }
            acornWalk[methodName](node, allVisitors, base, state);
        });
    });
};
const prepareWalk = () => {
    // Store a WalkArray for each method supported.
    const walkArrays = {
        ancestor: [],
        full: [],
        fullAncestor: [],
        simple: []
    };
    /**
     * Create a method that will create a WalkArray for a walk method (simple, full, etc.).
     */
    const getWalkAccumulator = (methodName) => {
        if (!walkArrays[methodName]) {
            walkArrays[methodName] = [];
        }
        /**
         * Every time a hint calls to walk.(simple|ancestor|full|fullAncestor), it is going to
         * execute this method, storing in a WalkArray object all the NodeVistors or Callbacks
         * the hints are defining for the walk method.
         *
         * This will allow later generate our custom NodeVisitor(s) or callback to call the
         * real `acorn-walk` method, so we just need to walk once for each Key (node + base + state)
         * and method.
         *
         * E.g:
         * For the script1.js
         *
         * hint 1: call to walk.simple(ast, {
         *     CallExpression(node) { // this is a NodeVisitor
         *         // any code here
         *     }
         * });
         *
         * hint 2: call to walk.simple(ast, {
         *     CallExpression(node) { // This is a NodeVisitor
         *         // any other code here
         *     }
         * });
         *
         * hint 3: call to walk.simple(ast, {
         *     Literal(node) { // This is a NodeVisitor
         *         // any code for Literal.
         *     }
         * });
         *
         * hint 4: call to walk.full(ast, (node) => {
         *   // Callback code here.
         * });
         *
         * These hints will create two WalkArray, one for the method `simple` and another one
         * for the method `full`.
         *
         * The WalkArray object for `simple` will have a map with 2 entries, the key of the first entry
         * will be `CallExpression` and the content for that entry will be an array with 2 NodeVisitors,
         * one from `hint 1`, and another from the `hint 2`. The key for the second entry will be `Literal`
         * and the content for that entry will be an array with 1 NodeVisitor the one from `hint 3`
         *
         * The WalkArray object for `full` will hava a map with 1 entry, the key of that entry will
         * be `callbacks`, and the content for that entry will be an array with 1 function. That function
         * is the function defined in `hint 4`
         */
        return (node, visitorsOrCallback, base, state) => {
            let currentVisitors = getCurrentVisitorsOrCallback(walkArrays[methodName], node, base, state);
            if (!currentVisitors) {
                currentVisitors = new Map();
                walkArrays[methodName].push([{ base, node, state }, currentVisitors]);
            }
            if (typeof visitorsOrCallback === 'function') {
                // `full` and `fullAncestor` only track an array of callbacks.
                const name = defaultCallbacksProperty;
                const visitorCallbacks = currentVisitors.get(name) || [];
                visitorCallbacks.push(visitorsOrCallback);
                currentVisitors.set(name, visitorCallbacks);
            }
            else {
                // `ancestor` and `simple` track an array of NodeVisitors.
                for (const [name, callback] of Object.entries(visitorsOrCallback)) {
                    const mapName = name;
                    const visitorCallbacks = currentVisitors.get(mapName) || [];
                    visitorCallbacks.push(callback);
                    currentVisitors.set(mapName, visitorCallbacks);
                }
            }
        };
    };
    const listeners = [];
    const onComplete = (listener) => {
        listeners.push(listener);
    };
    const walk = {
        ancestor: getWalkAccumulator('ancestor'),
        full: getWalkAccumulator('full'),
        fullAncestor: getWalkAccumulator('fullAncestor'),
        onComplete,
        simple: getWalkAccumulator('simple')
    };
    return { listeners, walk, walkArrays };
};
/**
 * Batch multiple AST `walk.*` calls during a registration period, then execute
 * them in a single pass of the AST.
 *
 * This improves performance by avoiding multiple redundant walks, but requires
 * registering an `onComplete` callback for consumers which need to
 * post-process accumulated state after the walk is finished.
 */
exports.combineWalk = async (register) => {
    const { listeners, walk, walkArrays } = prepareWalk();
    await register(walk);
    performWalk(walkArrays);
    await Promise.all(listeners.map((listener) => {
        return listener();
    }));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2Fsay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93YWxrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsd0NBQXdDO0FBSXhDLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUU3QyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsMENBQTBDO0FBUXJELFFBQUEsSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUM7QUFFbkMsTUFBTSw0QkFBNEIsR0FBRyxDQUFDLFNBQW9CLEVBQUUsSUFBVSxFQUFFLElBQWtCLEVBQUUsS0FBVyxFQUFFLEVBQUU7SUFDdkcsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRTtRQUNsQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDO0lBQ3pFLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2pDLENBQUMsQ0FBQztBQWdCRixNQUFNLHdCQUF3QixHQUFHLFdBQVcsQ0FBQztBQUU3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFDSCxNQUFNLFdBQVcsR0FBRyxDQUFDLFVBQXNCLEVBQUUsRUFBRTtJQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxFQUFFLEVBQUU7UUFDM0QsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLFFB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