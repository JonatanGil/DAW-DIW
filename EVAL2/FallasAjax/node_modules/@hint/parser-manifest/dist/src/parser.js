"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("hint/dist/src/lib/types");
const utils_string_1 = require("@hint/utils-string");
const utils_network_1 = require("@hint/utils-network");
const utils_json_1 = require("@hint/utils-json");
// Using `require` instead of `loadJSONFile` so this can be bundled with `extension-browser`.
const schema = require('./schema.json');
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class ManifestParser extends types_1.Parser {
    constructor(engine) {
        super(engine, 'manifest');
        // Event names.
        this.fetchEndEventName = 'fetch::end::manifest';
        this.fetchErrorEventName = 'fetch::error::manifest';
        this.fetchStartEventName = 'fetch::start::manifest';
        this.parseEndEventName = 'parse::end::manifest';
        this.parseErrorSchemaEventName = 'parse::error::manifest::schema';
        this.parseJSONErrorEventName = 'parse::error::manifest::json';
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        this.fetchedManifests = new Set();
        engine.on('element::link', this.fetchManifest.bind(this));
        engine.on('fetch::end::manifest', this.validateManifest.bind(this));
        engine.on('scan::end', this.onScanEnd.bind(this));
    }
    onScanEnd() {
        // Clear cached manifests so multiple runs work (e.g. in local connector).
        this.fetchedManifests.clear();
    }
    async fetchManifest(elementFound) {
        const { element, resource } = elementFound;
        /*
         * Check if the target is a local file, and if it is,
         * don't try to fetch the web app manifest file as it's
         * `href` value will most probably not map to anything
         * on disk and the request will fail.
         *
         * TODO: Remove this once things work as expected.
         */
        if (!utils_network_1.isHTTP(resource) && !utils_network_1.isHTTPS(resource)) {
            return;
        }
        // Check if the `link` tag is for the web app manifest.
        if (utils_string_1.normalizeString(element.getAttribute('rel')) !== 'manifest') {
            return;
        }
        // If so, check if a non-empty `href` was specified.
        const hrefValue = utils_string_1.normalizeString(element.getAttribute('href'));
        if (!hrefValue) {
            return;
        }
        // Try to fetch the web app manifest.
        const manifestURL = element.resolveUrl(hrefValue);
        /*
         * Don't fetch the manifest if it has already been fetched (as some
         * connectors fetch automatically).
         *
         * Note: This expects manifest fetches by a connector to occur first.
         * In theory a redundant fetch can still occur if the connector fetch
         * occurs second. This does not happen in practice as this check runs
         * after the page has been loaded (as part of the DOM traversal phase).
         */
        if (this.fetchedManifests.has(manifestURL)) {
            return;
        }
        await this.engine.emitAsync(this.fetchStartEventName, { resource });
        let manifestNetworkData;
        try {
            manifestNetworkData = await this.engine.fetchContent(manifestURL);
        }
        catch (error) {
            await this.engine.emitAsync(this.fetchErrorEventName, {
                element,
                error,
                hops: [manifestURL],
                resource: manifestURL
            });
            return;
        }
        // If the web app manifest was fetched successfully and hasn't already been seen.
        if (this.fetchedManifests.has(manifestURL)) {
            return;
        }
        await this.engine.emitAsync(this.fetchEndEventName, {
            element,
            request: manifestNetworkData.request,
            resource: manifestURL,
            response: manifestNetworkData.response
        });
    }
    async validateManifest(fetchEnd) {
        const { resource, response } = fetchEnd;
        if (this.fetchedManifests.has(resource)) {
            return;
        }
        this.fetchedManifests.add(resource);
        if (response.statusCode >= 400) {
            return;
        }
        await this.engine.emitAsync(`parse::start::manifest`, { resource });
        let result;
        /*
         * Try to see if the content of the web app manifest file
         * is a valid JSON.
         */
        try {
            result = utils_json_1.parseJSON(response.body.content);
        }
        catch (e) {
            await this.engine.emitAsync(this.parseJSONErrorEventName, {
                error: e,
                resource
            });
            return;
        }
        /*
         * Try to see if the content of the web app manifest file
         * is a valid acording to the schema.
         */
        const validationResult = utils_json_1.validate(schema, result.data, result.getLocation);
        if (!validationResult.valid) {
            await this.engine.emitAsync(this.parseErrorSchemaEventName, {
                error: new Error('Invalid manifest'),
                errors: validationResult.errors,
                groupedErrors: validationResult.groupedErrors,
                prettifiedErrors: validationResult.prettifiedErrors,
                resource
            });
            return;
        }
        /*
         * If it is, return the parsed content among with
         * other useful information about the manifest.
         */
        await this.engine.emitAsync(this.parseEndEventName, {
            getLocation: result.getLocation,
            parsedContent: validationResult.data,
            resource
        });
    }
}
exports.default = ManifestParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG1EQUtpQztBQUVqQyxxREFBcUQ7QUFDckQsdURBQXNEO0FBR3RELGlEQUE0RjtBQUk1Riw2RkFBNkY7QUFDN0YsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBRXhDLHdFQUF3RTtBQUV4RSxNQUFxQixjQUFlLFNBQVEsY0FBc0I7SUFlOUQsWUFBbUIsTUFBOEI7UUFDN0MsS0FBSyxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQWY5QixlQUFlO1FBRUUsc0JBQWlCLEdBQUcsc0JBQXNCLENBQUM7UUFDM0Msd0JBQW1CLEdBQUcsd0JBQXdCLENBQUM7UUFDL0Msd0JBQW1CLEdBQUcsd0JBQXdCLENBQUM7UUFFL0Msc0JBQWlCLEdBQUcsc0JBQXNCLENBQUM7UUFDM0MsOEJBQXlCLEdBQUcsZ0NBQWdDLENBQUM7UUFDN0QsNEJBQXVCLEdBQUcsOEJBQThCLENBQUM7UUFFMUUsb0VBQW9FO1FBRTVELHFCQUFnQixHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFLekMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMxRCxNQUFNLENBQUMsRUFBRSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNwRSxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFTyxTQUFTO1FBQ2IsMEVBQTBFO1FBQzFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNs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