"use strict";
/**
 * @fileoverview Abstraction over [`request`](https://github.com/request/request)
 * that allow us to handle certain cumbersome scenarios such us:
 * - Count redirects
 * - Decode responses that are not `utf-8`
 * - Expose the original response bytes
 * - Expose the body bytes
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const util_1 = require("util");
const zlib = require("zlib");
const request = require("request");
const iconv = require("iconv-lite");
const parseDataURL = require("data-urls"); // Using `require` as `data-urls` exports a function.
const utils_1 = require("@hint/utils");
const utils_network_1 = require("@hint/utils-network");
const utils_debug_1 = require("@hint/utils-debug");
const utils_string_1 = require("@hint/utils-string");
const redirects_1 = require("./redirects");
const debug = utils_debug_1.debug(__filename);
const decompressBrotli = util_1.promisify(zlib.brotliDecompress);
const decompressGzip = util_1.promisify(zlib.gunzip);
const inflateAsync = util_1.promisify(zlib.inflate);
const inflateRawAsync = util_1.promisify(zlib.inflateRaw);
/* istanbul ignore next */
const inflate = (buff) => {
    /*
     * We detect if the data conforms to RFC 1950 Section 2.2:
     * * CM (Compression Method, bits 0-3) field should be 8
     * * FCHECK (bits 0-4) should be a multiple of 31
     *
     * https://www.ietf.org/rfc/rfc1950.txt
     */
    if ((buff[0] & 0x0f) === 8 && (buff.readUInt16BE(0) % 31 === 0)) {
        return inflateAsync(buff);
    }
    return inflateRawAsync(buff);
};
const identity = (buff) => {
    return Promise.resolve(Buffer.from(buff));
};
const defaults = {
    encoding: null,
    followRedirect: false,
    headers: {
        'Accept-Encoding': 'gzip, deflate, br',
        'Accept-Language': 'en-US,en;q=0.8,es;q=0.6,fr;q=0.4',
        'Cache-Control': 'no-cache',
        DNT: 1,
        Pragma: 'no-cache',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'
    },
    jar: true,
    time: true,
    timeout: 30000
};
class Requester {
    constructor(customOptions) {
        /** Internal `redirectManager`. */
        this._redirects = new redirects_1.RedirectManager();
        /** Maximum number of redirects */
        this._maxRedirects = 10;
        if (customOptions) {
            customOptions.followRedirect = false;
            customOptions.rejectUnauthorized = false;
            this._maxRedirects = customOptions.maxRedirects || this._maxRedirects;
            if (customOptions.headers) {
                /*
                 * We lower case everything because someone could use 'ACCEPT-Encoding' and then we will have 2 different keys.
                 * `request` probably normalizes this already but this way it's explicit and we know the user's headers will
                 * always take precedence.
                 */
                customOptions.headers = Object.assign({}, utils_string_1.toLowerCaseKeys(defaults.headers), utils_string_1.toLowerCaseKeys(customOptions.headers));
            }
        }
        const options = Object.assign({}, defaults, customOptions);
        this._options = options;
        this._request = request.defaults(options);
    }
    /** Tries to decompress the given `Buffer` `content` using the given `decompressor` */
    async tryToDecompress(decompressor, content) {
        try {
            const result = await decompressor(content);
            return result;
        }
        catch (e) {
            /* istanbul ignore next */
            return null;
        }
    }
    /** Returns the functions to try to use in order for a given algorithm. */
    decompressors(algorithm) {
        const priorities = {
            br: 0,
            gzip: 1,
            deflate: 2,
            identity: 3
        };
        const functions = [
            decompressBrotli,
            decompressGzip,
            inflate,
            identity
        ];
        // In case of an algorithm not defined by us
        const priority = typeof priorities[algorithm.trim()] === 'undefined' ?
            priorities.identity :
            priorities[algorithm];
        return functions.slice(priority);
    }
    /**
     * Tries to uncompresses a buffer with fallbacks in case `content-encoding`
     * is not accurate. E.g.:
     * `Content-Encoding` is `br` but content is actually `gzip`. It will try
     * first with Brotli, then gzip, then return a copy of the original Buffer
     *
     */
    async decompressResponse(contentEncoding, rawBodyResponse) {
        const that = this;
        /*
         * The "Content-Encoding" header field indicates what content codings
         * have been applied to the representation, beyond those inherent in the
         * media type, and thus what decoding mechanisms have to be applied in
         * order to obtain data in the media type referenced by the Content-Type
         * header field. Content-Encoding is primarily used to allow a
         * representation.
         *
         * https://tools.ietf.org/html/rfc7231#section-3.1.2.2
         *
         * This means contentEncoding could be `gzip, br` and we will need to
         * unzip and unbrotli
         */
        const algorithms = contentEncoding ?
            contentEncoding.split(',') :
            ['']; // `contentEncoding` could be null. For our purposes '' is OK
        const decompressors = this.decompressors(algorithms.shift().trim()); // `algorithms` will have at least one item, so `shift()` won't return `undefined`.
        let rawBody = null;
        for (const decompressor of decompressors) {
            rawBody = await that.tryToDecompress(decompressor, rawBodyResponse);
            if (rawBody) {
                break;
            }
        }
        // There's another decompression we need to do
        if (rawBody && algorithms.length > 0) {
            return this.decompressResponse(algorithms.join(','), rawBody);
        }
        return rawBody;
    }
    /** Return the redirects for a given `uri`. */
    getRedirects(uri) {
        return this._redirects.calculate(uri);
    }
    getResourceNetworkDataFromDataUri(uri) {
        const parsedDataURL = parseDataURL(uri);
        const networkData = {
            request: {
                headers: {},
                url: uri
            },
            response: {
                body: {
                    content: parsedDataURL.body,
                    rawContent: parsedDataURL.body,
                    rawResponse: () => {
                        return Promise.resolve(parsedDataURL.body);
                    }
                },
                charset: parsedDataURL.mimeType.parameters.get('charset') || '',
                headers: {},
                hops: [],
                mediaType: parsedDataURL.mimeType.toString(),
                statusCode: 200,
                url: uri
            }
        };
        return networkData;
    }
    /**
     * Performs a `get` to the given `uri`.
     * If `Content-Type` is of type text and the charset is one of those supported by
     * [`iconv-lite`](https://github.com/ashtuchkin/iconv-lite/wiki/Supported-Encodings)
     * it will decode the response.
     */
    get(uri) {
        debug(`Requesting ${uri}`);
        if (uri.startsWith('data:')) {
            return Promise.resolve(this.getResourceNetworkDataFromDataUri(uri));
        }
        const requestedUrls = new Set();
        const getUri = (uriString) => {
            requestedUrls.add(uriString);
            return new Promise((resolve, reject) => {
                const byteChunks = [];
                let rawBodyResponse;
                this._request({ uri: uriString }, async (err, response) => {
                    if (err) {
                        debug(`Request for ${uriString} failed\n${err}`);
                        return reject({
                            error: err,
                            uri: uriString
                        });
                    }
                    // We check if we need to redirect and call ourselves again with the new target
                    if (Requester.validRedirects.includes(response.statusCode)) {
                        if (!response.headers.location) {
                            return reject({
                                error: new Error('Redirect location undefined'),
                                uri: uriString
                            });
                        }
                        const newUri = url.resolve(uriString, response.headers.location);
                        if (requestedUrls.has(newUri)) {
                            return reject(`'${uriString}' could not be fetched using ${this._options.method || 'GET'} method (redirect loop detected).`);
                        }
                        this._redirects.add(newUri, uriString);
                        const currentRedirectNumber = this._redirects.calculate(newUri).length;
                        if (currentRedirectNumber > this._maxRedirects) {
                            return reject(`The number of redirects(${currentRedirectNumber}) exceeds the limit(${this._maxRedirects}).`);
                        }
                        try {
                            debug(`Redirect found for ${uriString}`);
                            const results = await getUri(newUri);
                            return resolve(results);
                        }
                        catch (e) {
                            return reject(e);
                        }
                    }
                    const contentEncoding = utils_network_1.normalizeHeaderValue(response.headers, 'content-encoding');
                    const rawBody = await this.decompressResponse(contentEncoding, rawBodyResponse);
                    const contentTypeData = utils_1.getContentTypeData(null, uri, response.headers, rawBody);
                    const charset = contentTypeData.charset || '';
                    const mediaType = contentTypeData.mediaType || '';
                    const hops = this._redirects.calculate(uriString);
                    const body = rawBody && iconv.encodingExists(charset) ? iconv.decode(rawBody, charset) : null;
                    const networkData = {
                        request: {
                            headers: response.request.headers,
                            url: hops[0] || uriString
                        },
                        response: {
                            body: {
                                content: body,
                                rawContent: rawBody,
                                rawResponse: () => {
                                    return Promise.resolve(rawBodyResponse);
                                }
                            },
                            charset,
                            headers: response.headers,
                            hops,
                            mediaType,
                            statusCode: response.statusCode,
                            url: uriString
                        }
                    };
                    return resolve(networkData);
                })
                    /*
                     * Somehow the Buffer body from `callback(err, resp, body)` is different than the one we get
                     * if we do this method. Even though both output the same result after decompressing,
                     * the real bytes sent over the wire for the content are these ones.
                     *
                     * See: https://github.com/request/request/tree/6f286c81586a90e6a9d97055f131fdc68e523120#examples.
                     */
                    .on('response', (response) => {
                    response
                        .on('data', (data) => {
                        byteChunks.push(data);
                    })
                        .on('end', () => {
                        rawBodyResponse = Buffer.concat(byteChunks);
                    });
                });
            });
        };
        return getUri(uri);
    }
}
exports.Requester = Requester;
/** The valid status codes for redirects we follow. */
Requester.validRedirects = [301, 302, 303, 307, 308];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JlcXVlc3Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7R0FPRzs7QUFFSCwyQkFBMkI7QUFDM0IsK0JBQWlDO0FBQ2pDLDZCQUE2QjtBQUU3QixtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLDBDQUEyQyxDQUFDLHFEQUFxRDtBQUdqRyx1Q0FBaUQ7QUFDakQsdURBQTJEO0FBQzNELG1EQUErQztBQUMvQyxxREFBcUQ7QUFHckQsMkNBQThDO0FBSTlDLE1BQU0sS0FBSyxHQUFHLG1CQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDNUIsTUFBTSxnQkFBZ0IsR0FBRyxnQkFBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQzFELE1BQU0sY0FBYyxHQUFHLGdCQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzlDLE1BQU0sWUFBWSxHQUFHLGdCQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdDLE1BQU0sZUFBZSxHQUFHLGdCQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ25ELDBCQUEwQjtBQUMxQixNQUFNLE9BQU8sR0FBRyxDQUFDLElBQVksRUFBbUIsRUFBRTtJQUM5Qzs7Ozs7O09BTUc7SUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQzdELE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBUSxDQUFDO0tBQ3BDO0lBRUQsT0FBTyxlQUFlLENBQUMsSUFBSSxDQUFRLENBQUM7QUFDeEMsQ0FBQyxDQUFDO0FBRUYsTUFBTSxRQUFRLEdBQUcsQ0FBQyxJQUFZLEVBQW1CLEVBQUU7SUFD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