"use strict";
/**
 * @fileoverview This helper makes it easier to calculate the `hops` of a request
 */
Object.defineProperty(exports, "__esModule", { value: true });
class RedirectManager {
    constructor() {
        this._redirects = new Map();
    }
    /** Adds a new `hop` to the list */
    add(destination, source) {
        this._redirects.set(destination, source);
    }
    /**
     * Calculates the number of `hop`s for a given target.
     *
     *  Known issues: it doesn't support multiple redirects to the same url. This shouldn't happen very
     * often in the same page
     */
    calculate(target) {
        /*
         * To find the number of `hops` we look into the `redirects` `Map` which should look similar to:
         *
         * | key  | value |
         * |------|-------|
         * | url2 | url1  |
         * | url3 | url2  |
         * | url4 | url3  |
         *
         * `targetUrl` is initially `url4` (the url for what we got the response for). We make our way
         * up until `url1`. When we check if `url1` has any redirect, we don't find anything so we
         * know we've reached the original `resourceUrl` and we can stop looking.
         * Because `hops` always contains the latest url, we `pop` to have the intermediate requests.
         */
        let targetUrl = target;
        const hops = [targetUrl];
        while (this._redirects.has(targetUrl)) {
            targetUrl = this._redirects.get(targetUrl); // The `has` check above means this exists.
            /*
             * In some edgy cases the redirect ends in the
             * same URL that it starts.
             *
             * http://url1 => http://url2
             * http://url2 => http://url3
             * http://url3 => http://url1
             *
             * In these cases, the hop returned should contain
             * the first URL too:
             *
             * ['http://url1', 'http://url2', 'http://url3']
             */
            const finish = hops.includes(targetUrl);
            hops.unshift(targetUrl);
            if (finish) {
                break;
            }
        }
        hops.pop();
        return hops;
    }
}
exports.RedirectManager = RedirectManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkaXJlY3RzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JlZGlyZWN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUgsTUFBYSxlQUFlO0lBQTVCO1FBQ1ksZUFBVSxHQUF3QixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBNER4RCxDQUFDO0lBMURHLG1DQUFtQztJQUM1QixHQUFHLENBQUMsV0FBbUIsRUFBRSxNQUFjO1FBQzFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxTQUFTLENBQUMsTUFBYztRQUMzQjs7Ozs7Ozs7Ozs7OztXQWFHO1FBQ0gsSUFBSSxTQUFTLEdBQVcsTUFBTSxDQUFDO1FBQy9CLE1BQU0sSUFBSSxHQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbkMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNuQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFFLENBQUMsQ0FBQywyQ0FBMkM7WUFFeEY7Ozs7Ozs7Ozs7OztlQVlHO1lBRUgsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUV4QyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRXhCLElBQUksTUFBTSxFQUFFO2dCQUNSLE1BQU07YUFDVDtTQUNKO1FBQ0QsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRVgsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKO0FBN0RELDBDQTZEQyJ9