/**
 * @fileoverview Abstraction over [`request`](https://github.com/request/request)
 * that allow us to handle certain cumbersome scenarios such us:
 * - Count redirects
 * - Decode responses that are not `utf-8`
 * - Expose the original response bytes
 * - Expose the body bytes
 */
import * as request from 'request';
import { NetworkData } from 'hint';
export declare class Requester {
    /** The valid status codes for redirects we follow. */
    private static validRedirects;
    /** Internal `request` object. */
    private _request;
    /** Internal `redirectManager`. */
    private _redirects;
    /** Maximum number of redirects */
    private _maxRedirects;
    /** Internal options for request */
    private _options;
    /** Tries to decompress the given `Buffer` `content` using the given `decompressor` */
    private tryToDecompress;
    /** Returns the functions to try to use in order for a given algorithm. */
    private decompressors;
    /**
     * Tries to uncompresses a buffer with fallbacks in case `content-encoding`
     * is not accurate. E.g.:
     * `Content-Encoding` is `br` but content is actually `gzip`. It will try
     * first with Brotli, then gzip, then return a copy of the original Buffer
     *
     */
    private decompressResponse;
    constructor(customOptions?: request.CoreOptions);
    /** Return the redirects for a given `uri`. */
    getRedirects(uri: string): string[];
    private getResourceNetworkDataFromDataUri;
    /**
     * Performs a `get` to the given `uri`.
     * If `Content-Type` is of type text and the charset is one of those supported by
     * [`iconv-lite`](https://github.com/ashtuchkin/iconv-lite/wiki/Supported-Encodings)
     * it will decode the response.
     */
    get(uri: string): Promise<NetworkData>;
}
//# sourceMappingURL=requester.d.ts.map