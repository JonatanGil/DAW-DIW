"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fileType = require("file-type");
const is_svg_1 = require("is-svg");
const content_type_1 = require("content-type");
const utils_debug_1 = require("@hint/utils-debug");
const mime_db_1 = require("./mime-db");
const utils_fs_1 = require("@hint/utils-fs");
exports.getFileExtension = utils_fs_1.fileExtension;
const utils_string_1 = require("@hint/utils-string");
const debug = utils_debug_1.debug(__filename);
/*
 * ---------------------------------------------------------------------
 * Private methods
 * ---------------------------------------------------------------------
 */
const getMediaTypeBasedOnFileExtension = (fileExtension) => {
    return fileExtension && Object.keys(mime_db_1.default).find((key) => {
        return !!mime_db_1.default[key].extensions && mime_db_1.default[key].extensions.includes(fileExtension);
    }) || null; // if nothing is found, we return null to be consistent
};
const determineCharset = (originalCharset, mediaType) => {
    /*
     * Prior to HTML5, for web pages, `ISO-8859-1` was the
     * default charset:
     *
     * " For example, user agents typically assume that
     *   in the absence of other indicators, the character
     *   encoding is ISO-8859-1. "
     *
     * From: https://www.w3.org/TR/WD-html40-970708/html40.txt
     *
     * However, `ISO-8859-1` is not supported by node directly.
     * https://github.com/webhintio/hint/issues/89
     */
    const charsetAliases = new Map([
        ['iso-8859-1', 'latin1']
    ]);
    const defaultCharset = originalCharset && charsetAliases.get(originalCharset) || originalCharset;
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    const typeInfo = mime_db_1.default[mediaType || ''];
    let determinedCharset = typeInfo && utils_string_1.normalizeString(typeInfo.charset);
    if (defaultCharset && (determinedCharset === defaultCharset)) {
        return defaultCharset;
    }
    /*
     * If the determined charset is different from what the server
     * provided, try to figure out which one should be used.
     */
    /*
     * Check if (according to the determined media type) the
     * document is a binary file, and if it is, ignore the charset.
     */
    if (!isTextMediaType(mediaType || '')) { // eslint-disable-line no-use-before-define, @typescript-eslint/no-use-before-define
        return null;
    }
    /*
     * If it's a text based document, and the charset could
     * not be determined, default to `utf-8`.
     */
    determinedCharset = determinedCharset || 'utf-8';
    /*
     * If the charset was not specified, use the determined
     * one, otherwise, go with the specified one even though
     * it might not be the best charset (e.g.: `ISO-8859-1`
     * vs. `utf-8`).
     *
     * Notes:
     *
     *  * Not going with the specified charset when there is one
     *    might make some of our hints not detect some problems.
     *
     *  * The `content-type` role is responsable for suggesting
     *    the correct/best charset.
     */
    return defaultCharset ? defaultCharset : determinedCharset;
};
const determineMediaTypeForScript = (element) => {
    const typeAttribute = utils_string_1.normalizeString(element.getAttribute('type') || '');
    /*
     * Valid JavaScript media types:
     * https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type
     */
    const validJavaScriptMediaTypes = [
        'application/ecmascript',
        'application/javascript',
        'application/x-ecmascript',
        'application/x-javascript',
        'text/ecmascript',
        'text/javascript',
        'text/javascript1.0',
        'text/javascript1.1',
        'text/javascript1.2',
        'text/javascript1.3',
        'text/javascript1.4',
        'text/javascript1.5',
        'text/jscript',
        'text/livescript',
        'text/x-ecmascript',
        'text/x-javascript'
    ];
    /*
     * If the type attribute is:
     *
     *  * omitted (doesn't have a value, or is an empty string)
     *  * set to one of the valid JavaScript media types
     *  * 'module'
     *
     * it means the content is not intended as an data block,
     * and the official JavaScript media type can be suggested.
     *
     * See: https://html.spec.whatwg.org/multipage/scripting.html#attr-script-type
     */
    if (!typeAttribute ||
        validJavaScriptMediaTypes.includes(typeAttribute) ||
        typeAttribute === 'module') {
        /*
         * From https://html.spec.whatwg.org/multipage/scripting.html#scriptingLanguages
         *
         * " Servers should use `text/javascript` for JavaScript
         *   resources. Servers should not use other JavaScript
         *   MIME types for JavaScript resources, and must not
         *   use non-JavaScript MIME types. "
         */
        return 'text/javascript';
    }
    return null;
};
exports.determineMediaTypeForScript = determineMediaTypeForScript;
/* istanbul ignore next */
const determineMediaTypeBasedOnElement = (element) => {
    const nodeName = element && utils_string_1.normalizeString(element.nodeName);
    if (element && nodeName) {
        if (nodeName === 'script') {
            return determineMediaTypeForScript(element);
        }
        if (nodeName === 'link') {
            const relValue = element.getAttribute('rel');
            /* eslint-disable default-case */
            switch (relValue) {
                case 'stylesheet':
                    // See: https://tools.ietf.org/html/rfc2318.
                    return 'text/css';
                case 'manifest':
                    // See: https://w3c.github.io/manifest/#media-type-registration.
                    return 'application/manifest+json';
            }
            /* eslint-enable default-case */
        }
    }
    return null;
};
const determineMediaTypeBasedOnFileExtension = (resource, originalMediaType = null) => {
    const fileExtension = utils_fs_1.fileExtension(resource);
    if (!fileExtension) {
        return null;
    }
    /*
     * The following list is order based on the expected encounter
     * rate and different statistics (e.g. for images, except `ico`,
     * http://httparchive.org/interesting.php#imageformats)
     */
    /*
     * The reasons for hard-coding some of the values here are:
     *
     *  * `mime-db` is quite big, so querying it is expensive.
     *  * `mime-db` sometimes has multiple media types for
     *     the same file type (e.g.: for `js` the result will be
     *     "application/javascript" instead of what this project
     *     recommends, namely `text/javascript`).
     *
     * See also: http://www.iana.org/assignments/media-types/media-types.xhtml
     */
    /* eslint-disable default-case */
    switch (fileExtension) {
        case 'html':
        case 'htm':
            return 'text/html';
        case 'php':
            /**
             * originalMediaType will be null for connector local.
             * In local connector, php doesn't need to be processed
             * as html.
             */
            if (originalMediaType) {
                return 'text/html';
            }
            break;
        case 'xhtml':
            return 'application/xhtml+xml';
        case 'js':
            return 'text/javascript';
        case 'ts':
        case 'tsx':
            return 'text/x-typescript';
        case 'css':
            return 'text/css';
        case 'ico':
            return 'image/x-icon';
        case 'webmanifest':
            // See: https://w3c.github.io/manifest/#media-type-registration.
            return 'application/manifest+json';
        case 'jpeg':
        case 'jpg':
            return 'image/jpeg';
        case 'png':
            return 'image/png';
        case 'gif':
            return 'image/gif';
        case 'svg':
            // See: https://www.w3.org/TR/SVG/mimereg.html.
            return 'image/svg+xml';
        case 'webp':
            return 'image/webp';
        case 'woff2':
            return 'font/woff2';
        case 'woff':
            return 'font/woff';
        case 'ttf':
            return 'font/ttf';
        case 'otf':
            return 'font/otf';
        case 'xml':
            // See: https://tools.ietf.org/html/rfc3023#page-5.
            return 'text/xml';
    }
    /* eslint-enable default-case */
    // If the file extension is not in the list above, query `mime-db`.
    return getMediaTypeBasedOnFileExtension(fileExtension);
};
exports.determineMediaTypeBasedOnFileExtension = determineMediaTypeBasedOnFileExtension;
/**
 * Determine the media type based on the file name, extension and content.
 * This is only for edge cases. So far it detects:
 *
 * * `.configrc` files: If the content is a valid `json`, it will return `text/json`, `text/plain` otherwise
 *
 */
const determineMediaTypeBasedOnFileName = (resource, rawContent) => {
    const fileName = utils_fs_1.fileName(resource);
    if (!fileName) {
        return null;
    }
    const configFileNameRegex = /^\.[a-z0-9]+rc$/i;
    if (!configFileNameRegex.test(fileName)) {
        return null;
    }
    try {
        // Determine if this is a json file.
        JSON.parse(rawContent.toString());
    }
    catch (err) {
        return 'text/plain';
    }
    return 'text/json';
};
exports.determineMediaTypeBasedOnFileName = determineMediaTypeBasedOnFileName;
/* istanbul ignore next */
const determineMediaTypeBasedOnFileType = (rawContent) => {
    if (!rawContent) {
        return null;
    }
    const detectedFileType = fileType(rawContent);
    if (detectedFileType) {
        /*
         * If the file is XML, check if it's a specific
         * type of XML such as a SVG.
         */
        if (detectedFileType.mime === 'application/xml' &&
            is_svg_1.default(rawContent)) {
            // See: https://www.w3.org/TR/SVG/mimereg.html.
            return 'image/svg+xml';
        }
        // Use the media types from `mime-db`, not `file-type`.
        return getMediaTypeBasedOnFileExtension(detectedFileType.ext);
    }
    return null;
};
/* istanbul ignore next */
const getPreferedMediaType = (mediaType) => {
    // Prefer certain media types over others.
    switch (mediaType) {
        case 'application/xml':
            /*
             * From https://tools.ietf.org/html/rfc3023#page-5:
             *
             *  " If an XML document -- that is, the unprocessed,
             *    source XML document -- is readable by casual users,
             *    text/xml is preferable to application/xml. "
             */
            return 'text/xml';
        default:
            return mediaType;
    }
};
/* istanbul ignore next */
const parseContentTypeHeader = (headers) => {
    const contentTypeHeaderValue = utils_string_1.normalizeString(headers ? headers['content-type'] : null);
    // Check if the `Content-Type` header was sent.
    if (contentTypeHeaderValue === null) {
        debug(`'content-type' header was not specified`);
        return null;
    }
    // Check if the `Content-Type` header was sent with a valid value.
    let contentType;
    /* istanbul ignore next */
    try {
        if (contentTypeHeaderValue === '') {
            throw new TypeError('invalid media type');
        }
        contentType = content_type_1.parse(contentTypeHeaderValue);
    }
    catch (e) {
        debug(`'content-type' header value is invalid (${e.message})`);
        return null;
    }
    return contentType;
};
/*
 * ---------------------------------------------------------------------
 * Public methods
 * ---------------------------------------------------------------------
 */
/*
 * Try to determine the media type and charset based on the response's
 * content-type header value, but also (because sometimes serers are
 * misconfigured) on things such as the file type, element type, and
 * file extension.
 */
/* istanbul ignore next */
const getContentTypeData = (element, resource, headers, rawContent) => {
    let originalMediaType = null;
    let originalCharset = null;
    const contentType = parseContentTypeHeader(headers);
    if (contentType) {
        originalCharset = contentType.parameters ? contentType.parameters.charset : null;
        originalMediaType = contentType.type;
    }
    /*
     * Try to determine the media type and charset using
     * what the server specified, but also other available
     * information, as sometimes servers are misconfigured.
     */
    let mediaType = determineMediaTypeBasedOnElement(element) ||
        determineMediaTypeBasedOnFileType(rawContent) ||
        determineMediaTypeBasedOnFileExtension(resource, originalMediaType) ||
        determineMediaTypeBasedOnFileName(resource, rawContent) ||
        originalMediaType;
    mediaType = getPreferedMediaType(mediaType);
    const charset = determineCharset(originalCharset, mediaType);
    return {
        charset,
        mediaType
    };
};
exports.getContentTypeData = getContentTypeData;
/** Checks if a media type is one of a file type that is text based. */
const isTextMediaType = (mediaType) => {
    const textMediaTypes = [
        /application\/(?:javascript|json|x-javascript|xml)/i,
        /application\/.*\+(?:json|xml)/i,
        /image\/svg\+xml/i,
        /text\/.*/i
    ];
    if (textMediaTypes.some((regex) => {
        return regex.test(mediaType);
    })) {
        return true;
    }
    return false;
};
exports.isTextMediaType = isTextMediaType;
/**
 * Returns the group to which the mediaType belongs to. E.g.:
 * `image`, `font`, `script`, `css`, `html`, `manifest`, `xml`
 * or `unkown`.
 */
const getType = (mediaType) => {
    // e.g, `.babelrc`, mediaType can't be decided from extension or from the file type.
    if (!mediaType) {
        return 'unknown';
    }
    if (mediaType.startsWith('image')) {
        return 'image';
    }
    if (mediaType.startsWith('font') || mediaType === 'application/vnd.ms-fontobject') {
        return 'font';
    }
    /* eslint-disable default-case */
    switch (mediaType) {
        case 'application/javascript':
        case 'text/javascript':
            return 'script';
        case 'text/css':
            return 'css';
        case 'application/json':
        case 'text/json':
            return 'json';
        case 'application/manifest+json':
            return 'manifest';
        case 'text/html':
        case 'application/xhtml+xml':
            return 'html';
        case 'text/xml':
            return 'xml';
        case 'text/plain':
            return 'txt';
    }
    /* eslint-enable default-case */
    return 'unknown';
};
exports.getType = getType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC10eXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbnRlbnQtdHlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHNDQUF1QztBQUN2QyxtQ0FBMkI7QUFFM0IsK0NBQWdEO0FBR2hELG1EQUErQztBQUMvQyx1Q0FBK0I7QUFFL0IsNkNBQTRGO0FBc2V4RiwyQkF0ZXNCLHdCQUFnQixDQXNldEI7QUFyZXBCLHFEQUFxRDtBQUVyRCxNQUFNLEtBQUssR0FBRyxtQkFBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBRTVCOzs7O0dBSUc7QUFDSCxNQUFNLGdDQUFnQyxHQUFHLENBQUMsYUFBcUIsRUFBaUIsRUFBRTtJQUM5RSxPQUFPLGFBQWEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtRQUNyRCxPQUFPLENBQUMsQ0FBQyxpQkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsSUFBSSxpQkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdkYsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsdURBQXVEO0FBQ3ZFLENBQUMsQ0FBQztBQUVGLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxlQUE4QixFQUFFLFNBQXdCLEVBQWlCLEVBQUU7SUFFakc7Ozs7Ozs7Ozs7OztPQVlHO0lBRUgsTUFBTSxjQUFjLEdBQXdCLElBQUksR0FBRyxDQUFDO1FBQ2hELENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQztLQUMzQixDQUFDLENBQUM7SUFFSCxNQUFNLGNBQWMsR0FBRyxlQUFlLElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsSUFBSSxlQUFlLENBQUM7SUFFakcsb0VBQW9FO0lBRXBFLE1BQU0sUUFBUSxHQUFJLGlCQUFjLENBQUMsU0FBUyxJQUFJLEVB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