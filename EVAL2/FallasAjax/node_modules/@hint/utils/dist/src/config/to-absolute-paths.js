"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
exports.toAbsolutePaths = (config, configRoot) => {
    if (!config) {
        return null;
    }
    /*
     * We could receive a path to a folder or a file. `dirname` will return different
     * things depending on that. E.g.:
     * * `path.dirname('/config/folder')` will return `/config` and we want `/config/folder`
     * * `path.dirname('/config/folder/file')` will return `/config/folder`
     *
     * This is no good if we want to resolve relatively because we will get incorrect
     * paths. To solve this we have to know if what we are receiving is a file or a
     * folder and adjust accordingly.
     */
    const stat = fs.statSync(configRoot); //eslint-disable-line
    const configPath = stat.isDirectory() ? configRoot : path.dirname(configRoot);
    /* istanbul ignore if */
    if (!configPath) {
        return config;
    }
    /**
     * If `value` is a relative path (i.e. it starts with `.`), it transforms it
     * to an absolute path using the `configRoot` folder as the origin to `resolve`.
     */
    const resolve = (value) => {
        if (!value.startsWith('.')) {
            return value;
        }
        return path.resolve(configPath, value);
    };
    // Update the connector value
    if (config.connector) {
        if (typeof config.connector === 'string') {
            config.connector = resolve(config.connector);
        }
        else {
            config.connector.name = resolve(config.connector.name);
        }
    }
    // Update extends
    if (config.extends) {
        config.extends = config.extends.map(resolve);
    }
    // Update formatters
    if (config.formatters) {
        config.formatters = config.formatters.map(resolve);
    }
    // Update parsers
    if (config.parsers) {
        config.parsers = config.parsers.map(resolve);
    }
    // Update hints
    if (config.hints) {
        const hints = Array.isArray(config.hints) ? config.hints : Object.keys(config.hints);
        if (Array.isArray(config.hints)) {
            config.hints = hints.map((currentHint) => {
                if (typeof currentHint === 'string') {
                    return resolve(currentHint);
                }
                currentHint[0] = resolve(currentHint[0]);
                return currentHint;
            });
        }
        else {
            const transformedHints = hints.reduce((newHints, currentHint) => {
                const newHint = resolve(currentHint);
                newHints[newHint] = config.hints[currentHint];
                return newHints;
            }, {});
            config.hints = transformedHints;
        }
    }
    return config;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG8tYWJzb2x1dGUtcGF0aHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29uZmlnL3RvLWFic29sdXRlLXBhdGhzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUloQixRQUFBLGVBQWUsR0FBRyxDQUFDLE1BQXlCLEVBQUUsVUFBa0IsRUFBcUIsRUFBRTtJQUNoRyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUM7S0FDZjtJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxxQkFBcUI7SUFDM0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFOUUsd0JBQXdCO0lBQ3hCLElBQUksQ0FBQyxVQUFVLEVBQUU7UUFDYixPQUFPLE1BQU0sQ0FBQztLQUNqQjtJQUVEOzs7T0FHRztJQUNILE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBYSxFQUFVLEVBQUU7UUFDdEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzNDLENBQUMsQ0FBQztJQUVGLDZCQUE2QjtJQUM3QixJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7UUFDbEIsSUFBSSxPQUFPLE1BQU0sQ0FBQyxTQUFTLEtBQUssUUFBUSxFQUFFO1lBQ3RDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNoRDthQUFNO1lBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDMUQ7S0FDSjtJQUVELGlCQUFpQjtJQUNqQixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7UUFDaEIsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNoRDtJQUVELG9CQUFvQjtJQUNwQixJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUU7UUFDbkIsTUFBTSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUN0RDtJQUVELGlCQUFpQjtJQUNqQixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7UUFDaEIsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNoRDtJQUVELGVBQWU7SUFDZixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7UUFDZCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFckYsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM3QixNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDckMsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLEVBQUU7b0JBQ2pDLE9BQU8sT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUMvQjtnQkFFRCxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUV6QyxPQUFPLFdBQVcsQ0FBQztZQUN2QixDQUFDLENBQUMsQ0FBQztTQUNOO2FBQU07WUFDSCxNQUFNLGdCQUFnQixHQUFJLEtBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxFQUFFO2dCQUMxRSxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBRXJDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBSSxNQUFNLENBQUMsS0FBMkIsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFFckUsT0FBTyxRQUFRLENBQUM7WUFDcEIsQ0FBQyxFQUFFLEVBQXVCLENBQUMsQ0FBQztZQUU1QixNQUFNLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDO1NBQ25DO0tBQ0o7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUMifQ==