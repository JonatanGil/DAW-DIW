/// <reference types="node" />
import { HTMLElement } from '@hint/utils-dom';
import { HttpHeaders } from '@hint/utils-types';
import { fileExtension as getFileExtension } from '@hint/utils-fs';
declare const determineMediaTypeForScript: (element: HTMLElement) => string | null;
declare const determineMediaTypeBasedOnFileExtension: (resource: string, originalMediaType?: string | null) => string | null;
/**
 * Determine the media type based on the file name, extension and content.
 * This is only for edge cases. So far it detects:
 *
 * * `.configrc` files: If the content is a valid `json`, it will return `text/json`, `text/plain` otherwise
 *
 */
declare const determineMediaTypeBasedOnFileName: (resource: string, rawContent: Buffer) => string | null;
declare const getContentTypeData: (element: HTMLElement | null, resource: string, headers: HttpHeaders | null, rawContent: Buffer) => {
    charset: string | null;
    mediaType: string | null;
};
/** Checks if a media type is one of a file type that is text based. */
declare const isTextMediaType: (mediaType: string) => boolean;
/**
 * Returns the group to which the mediaType belongs to. E.g.:
 * `image`, `font`, `script`, `css`, `html`, `manifest`, `xml`
 * or `unkown`.
 */
declare const getType: (mediaType: string) => "script" | "manifest" | "html" | "css" | "xml" | "unknown" | "image" | "font" | "json" | "txt";
export { determineMediaTypeBasedOnFileExtension, determineMediaTypeBasedOnFileName, determineMediaTypeForScript, getContentTypeData, getFileExtension, getType, isTextMediaType };
//# sourceMappingURL=content-type.d.ts.map