"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parse5 = require("parse5");
const htmlparser2Adapter = require("parse5-htmlparser2-tree-adapter");
const find_original_element_1 = require("./find-original-element");
class HTMLElement {
    constructor(element, ownerDocument) {
        this._element = element instanceof HTMLElement ? element._element : element;
        this.ownerDocument = ownerDocument;
    }
    get attributes() {
        const x = this._element.attribs;
        return Object.entries(x).map(([name, value]) => {
            return {
                name,
                value
            };
        });
    }
    get children() {
        const result = [];
        for (const child of this._element.children) {
            if (child.type === 'tag' || child.type === 'script' || child.type === 'style') {
                result.push(new HTMLElement(child, this.ownerDocument));
            }
        }
        return result;
    }
    get parentElement() {
        const parent = this._element.parent;
        if (!parent || (parent.type !== 'tag' && parent.type !== 'script' && parent.type !== 'style')) {
            return null;
        }
        return new HTMLElement(parent, this.ownerDocument);
    }
    get nodeName() {
        return this._element.name;
    }
    getAttribute(attribute) {
        const attrib = this._element.attribs[attribute];
        const value = typeof attrib !== 'undefined' ? attrib : null;
        return value;
    }
    isAttributeAnExpression(attribute) {
        const value = this.getAttribute(attribute);
        return value ? value.includes('{') : false;
    }
    _getOriginalLocation() {
        const location = this._element.sourceCodeLocation;
        if (location) {
            return location;
        }
        if (this.ownerDocument.originalDocument) {
            const match = find_original_element_1.findOriginalElement(this.ownerDocument.originalDocument, this);
            if (match) {
                return match._element.sourceCodeLocation || null;
            }
        }
        return null;
    }
    getLocation() {
        const location = this._getOriginalLocation();
        return {
            column: location ? location.startCol : -1,
            elementId: this._element.id,
            endOffset: location ? location.endOffset : -1,
            line: location ? location.startLine - 1 : -1,
            startOffset: location ? location.startOffset : -1
        };
    }
    getContentLocation(offset) {
        const location = this._getOriginalLocation();
        if (!location) {
            return null;
        }
        const startTag = location.startTag;
        const column = startTag.endCol - 1;
        const line = startTag.endLine - 1;
        if (offset.line === 0) {
            return {
                column: column + offset.column,
                line
            };
        }
        return {
            column: offset.column,
            line: line + offset.line
        };
    }
    isSame(element) {
        return this._element === element._element;
    }
    get innerHTML() {
        return parse5.serialize(this._element, { treeAdapter: htmlparser2Adapter });
    }
    get outerHTML() {
        const fragment = htmlparser2Adapter.createDocumentFragment();
        const { parent, next, prev } = this._element;
        htmlparser2Adapter.appendChild(fragment, this._element);
        const result = parse5.serialize(fragment, { treeAdapter: htmlparser2Adapter });
        this._element.parent = parent;
        this._element.next = next;
        this._element.prev = prev;
        if (next) {
            next.prev = this._element;
        }
        if (prev) {
            prev.next = this._element;
        }
        return result;
    }
    resolveUrl(url) {
        return this.ownerDocument.resolveUrl(url);
    }
}
exports.HTMLElement = HTMLElement;
