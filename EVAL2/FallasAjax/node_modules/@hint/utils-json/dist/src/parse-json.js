"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsonc_parser_1 = require("jsonc-parser");
const rxIsNumber = /^[0-9]+$/;
class JSONResult {
    constructor(data, root, lines, alternatePath) {
        this._data = data;
        this._lines = lines;
        this._root = root;
        this._alternatePath = alternatePath;
        // Ensure `getLocation` can be passed around without losing context
        this.getLocation = this.getLocation.bind(this);
    }
    get data() {
        return this._data;
    }
    getLocation(path, options) {
        const segments = this.pathToSegments(path);
        let node = null;
        while (!node && segments.length > 0) {
            /* istanbul ignore next */
            node = jsonc_parser_1.findNodeAtLocation(this._root, segments) || null;
            segments.pop();
        }
        /**
         * The node isn't in the current file. Use alternative path if provided. This happens
         * when extending configurations.
         */
        /* istanbul ignore next */
        if (!node && this._alternatePath && path !== this._alternatePath) {
            return this.getLocation(this._alternatePath, options);
        }
        return this.offsetToLocation(this.getAdjustedOffset(node, path, options));
    }
    /* istanbul ignore next */
    scope(path) {
        const segments = this.pathToSegments(path);
        const node = jsonc_parser_1.findNodeAtLocation(this._root, segments);
        const value = this.findValueAtLocation(segments);
        return node ? new JSONResult(value, node, this._lines) : null;
    }
    /**
     * Determine the best offset to point to given the provided context.
     */
    getAdjustedOffset(node, path, options) {
        // Point to the root if nothing better is available
        /* istanbul ignore if */
        if (!node) {
            return this._root.offset;
        }
        // Point to the value if requested (default location returned by jsonc-parser)
        /* istanbul ignore next */
        if (options && options.at === 'value') {
            return node.offset;
        }
        // Point to the value for array items
        /* istanbul ignore if */
        if (path.endsWith(']')) {
            return node.offset;
        }
        // Point to the value if there's no parent
        /* istanbul ignore if */
        if (!node.parent) {
            return node.offset;
        }
        // Otherwise point to the name
        return node.parent.offset + 1; // +1 to get past the quote (")
    }
    /**
     * Find the value at the given path in the JSON DOM.
     * @param segments The path to the value.
     */
    /* istanbul ignore next */
    findValueAtLocation(segments) {
        let value = this._data;
        segments.forEach((segment) => {
            value = value[segment];
        });
        return value;
    }
    /**
     * Convert a source offset into a `ProblemLocation` with line/column data.
     * @param offset The offset in the original source.
     */
    offsetToLocation(offset) {
        for (let i = 0, n = 0; i < this._lines.length; i++) {
            const lineLength = this._lines[i].length;
            if (offset <= n + lineLength) {
                return {
                    column: offset - n,
                    line: i
                };
            }
            // Move to the next line (+1 to account for the newline)
            n += lineLength + 1;
        }
        return null;
    }
    /**
     * Convert a JS-style path string to the `Segment` array needed by jsonc-parser.
     * @param path The path to convert (e.g. `foo.items[1].bar`).
     * @returns An array of `Segment` properties (e.g. `['foo', 'items', 1, 'bar']`).
     */
    pathToSegments(path) {
        return path
            // Strip leading dot (.) if present (ajv bug?)
            .replace(/^\./, '')
            // Ignore trailing `]` from `foo[1]`
            .replace(/]/g, '')
            // Break items on `.` or `[`
            .split(/[[.]/)
            // Ensure numbers are not returned as strings
            .map((k) => {
            /* istanbul ignore next */
            return rxIsNumber.test(k) ? parseInt(k) : k;
        });
    }
}
/**
 * Parse the provided JSON returning a `JSONResult` with location information.
 * @param json The JSON string to parse
 * @param alternatePath The alternative `path` to use when one is not found
 */
exports.parseJSON = (json, alternatePath) => {
    const lines = json.split('\n');
    const data = jsonc_parser_1.parse(json);
    const root = jsonc_parser_1.parseTree(json);
    // If we didn't get a root, it's invalid JSON
    /* istanbul ignore if */
    if (!root) {
        // Use the built-in JSON parser to get an error
        JSON.parse(json);
    }
    return new JSONResult(data, root, lines, alternatePath);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtanNvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZS1qc29uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0NBQW1GO0FBSW5GLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQztBQUU5QixNQUFNLFVBQVU7SUFPWixZQUFtQixJQUFTLEVBQUUsSUFBVSxFQUFFLEtBQWUsRUFBRSxhQUFzQjtRQUM3RSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsY0FBYyxHQUFHLGFBQWEsQ0FBQztRQUVwQyxtRUFBbUU7UUFDbkUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsSUFBVyxJQUFJO1FBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFFTSxXQUFXLENBQUMsSUFBWSxFQUFFLE9BQTZCO1FBQzFELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0MsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBRWhCLE9BQU8sQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDakMsMEJBQTBCO1lBQzFCLElBQUksR0FBRyxpQ0FBa0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQztZQUV4RCxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDbEI7UUFFRDs7O1dBR0c7UUFDSCwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksS0FBSyxJQUFJLENB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